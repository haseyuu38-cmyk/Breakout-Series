<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Breakout - Speed Up Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; touch-action: none; }
        canvas { display: block; background: #000; margin: 0 auto; }
        
        /* タイム表示 */
        #timer {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 20px; font-weight: bold; z-index: 10;
        }

        /* オーバーレイ共通 */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 20;
        }
        .overlay img { max-width: 80%; margin-bottom: 20px; }
        .message { color: gold; font-size: 30px; margin-bottom: 20px; text-shadow: 2px 2px #000; }
        
        button {
            padding: 15px 30px; font-size: 18px; margin: 10px; cursor: pointer;
            border-radius: 10px; border: none; background: #fff; font-weight: bold;
        }
        #btn-continue { background: #ffeb3b; }
        #btn-restart { background: #ff5722; color: white; }
        #btn-start { background: #4caf50; color: white; }
    </style>
</head>
<body>

    <div id="timer">TIME: 0.00s</div>

    <div id="start-screen" class="overlay" style="display: flex;">
        <div class="message">TAP TO START</div>
        <button id="btn-start">ゲーム開始</button>
    </div>

    <div id="miss-screen" class="overlay">
        <img src="Miss.png" alt="Miss">
        <button id="btn-continue">あきらめない</button>
        <button id="btn-restart-miss">最初からやり直す</button>
    </div>

    <div id="clear-screen" class="overlay">
        <img src="Image.png" alt="Clear">
        <div class="message">おめでとう〜♪</div>
        <button id="btn-restart-clear">もう一度遊ぶ</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const timerElement = document.getElementById("timer");

    // キャンバスサイズ設定
    canvas.width = window.innerWidth > 480 ? 480 : window.innerWidth;
    canvas.height = window.innerHeight;

    // ゲーム状態
    let isRunning = false;
    let startTime = 0;
    let elapsedTime = 0;
    let animationId;

    // ボール設定
    let ball = { x: 0, y: 0, dx: 4, dy: -4, radius: 8 };
    
    // 【新機能】速度倍率
    let speedMultiplier = 1.0;
    const MAX_SPEED_MULTIPLIER = 2.0; // 最大2倍まで
    const SPEED_INCREMENT = 0.00015;  // 毎フレームの加速量

    // パドル設定
    const paddleHeight = 15;
    const paddleWidth = 80;
    let paddleX = (canvas.width - paddleWidth) / 2;

    // ブロック設定
    const rowCount = 5;
    const columnCount = 6;
    const brickPadding = 5;
    const brickOffsetTop = 60;
    const brickWidth = (canvas.width - (brickPadding * (columnCount + 1))) / columnCount;
    const brickHeight = 25;
    let bricks = [];

    function initBricks() {
        bricks = [];
        for(let c=0; c<columnCount; c++) {
            bricks[c] = [];
            for(let r=0; r<rowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
    }

    function initBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height - 50;
        ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = -4;
        speedMultiplier = 1.0; // 速度をリセット
    }

    // 操作系（相対移動）
    document.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const movementX = touch.clientX - (lastTouchX || touch.clientX);
        paddleX += movementX;
        if(paddleX < 0) paddleX = 0;
        if(paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
        lastTouchX = touch.clientX;
    }, { passive: false });

    let lastTouchX = 0;
    document.addEventListener("touchstart", (e) => { lastTouchX = e.touches[0].clientX; });

    // 衝突判定
    function collisionDetection() {
        for(let c=0; c<columnCount; c++) {
            for(let r=0; r<rowCount; r++) {
                let b = bricks[c][r];
                if(b.status === 1) {
                    if(ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
                        ball.dy = -ball.dy;
                        b.status = 0;
                        checkWin();
                    }
                }
            }
        }
    }

    function checkWin() {
        const remaining = bricks.flat().filter(b => b.status === 1).length;
        if(remaining === 0) {
            isRunning = false;
            document.getElementById("clear-screen").style.display = "flex";
        }
    }

    function draw() {
        if(!isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ボールの加速処理
        if (speedMultiplier < MAX_SPEED_MULTIPLIER) {
            speedMultiplier += SPEED_INCREMENT;
        }

        // ブロック描画
        for(let c=0; c<columnCount; c++) {
            for(let r=0; r<rowCount; r++) {
                if(bricks[c][r].status === 1) {
                    let bx = (c * (brickWidth + brickPadding)) + brickPadding;
                    let by = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    bricks[c][r].x = bx;
                    bricks[c][r].y = by;
                    ctx.fillStyle = `hsl(${r * 40}, 70%, 50%)`;
                    ctx.fillRect(bx, by, brickWidth, brickHeight);
                }
            }
        }

        // パドル描画
        ctx.fillStyle = "#0095DD";
        ctx.fillRect(paddleX, canvas.height - paddleHeight - 20, paddleWidth, paddleHeight);

        // ボール描画
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.closePath();

        // 移動（倍率適用）
        ball.x += ball.dx * speedMultiplier;
        ball.y += ball.dy * speedMultiplier;

        // 壁バウンド
        if(ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx = -ball.dx;
        if(ball.y - ball.radius < 0) ball.dy = -ball.dy;

        // パドル判定
        if(ball.y + ball.radius > canvas.height - paddleHeight - 20) {
            if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
                ball.dy = -Math.abs(ball.dy);
            } else if(ball.y > canvas.height) {
                // ミス
                isRunning = false;
                document.getElementById("miss-screen").style.display = "flex";
            }
        }

        collisionDetection();
        updateTimer();
        animationId = requestAnimationFrame(draw);
    }

    function updateTimer() {
        elapsedTime = (Date.now() - startTime) / 1000;
        timerElement.innerText = `TIME: ${elapsedTime.toFixed(2)}s`;
    }

    // ボタンイベント
    document.getElementById("btn-start").onclick = () => {
        document.getElementById("start-screen").style.display = "none";
        startGame();
    };

    document.getElementById("btn-continue").onclick = () => {
        document.getElementById("miss-screen").style.display = "none";
        initBall(); // 速度も1.0にリセット
        isRunning = true;
        startTime = Date.now() - (elapsedTime * 1000); // タイム再開
        draw();
    };

    const restartAll = () => {
        location.reload();
    };

    document.getElementById("btn-restart-miss").onclick = restartAll;
    document.getElementById("btn-restart-clear").onclick = restartAll;

    function startGame() {
        initBricks();
        initBall();
        startTime = Date.now();
        isRunning = true;
        draw();
    }
</script>
</body>
</html>
