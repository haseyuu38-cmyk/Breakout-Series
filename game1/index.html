<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>ちっくゲーム - Final Fix</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; background-color: #fce4ec; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; touch-action: none; overflow: hidden; }
        #game-header { width: 100%; height: 50px; display: none; justify-content: center; align-items: center; margin-top: 5px; }
        #timer-box { background: #ad1457; color: white; padding: 5px 25px; border-radius: 20px; font-weight: bold; font-size: 20px; }
        .content-frame { width: 95%; max-width: 480px; margin: 10px auto 0 auto; position: relative; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border-radius: 10px; overflow: hidden; background: #fff; z-index: 10; }
        #portrait-frame { aspect-ratio: 2 / 3; display: block; }
        #landscape-frame { aspect-ratio: 3 / 2; display: none; }
        #puzzle-frame { aspect-ratio: 1 / 1; display: none; }
        canvas { width: 100%; height: 100%; display: block; background: #fff; touch-action: none; }
        .full-asset { width: 100%; height: 100%; object-fit: cover; display: block; }
        #puzzle-info-area { display: none; flex-direction: column; align-items: center; margin-top: 5px; width: 100%; }
        #puzzle-sample-img { width: 70px; height: 70px; object-fit: cover; border: 2px solid #ad1457; border-radius: 8px; margin-bottom: 2px; }
        #puzzle-stats { font-size: 16px; font-weight: bold; color: #ad1457; }
        #puzzle-board { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 100%; height: 100%; gap: 1px; background: #333; }
        .tile { width: 100%; height: 100%; background-image: url("image-3.jpg"); background-size: 300% 300%; background-repeat: no-repeat; }
        .empty { background: #eee !important; background-image: none !important; }
        #clear-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; background: #fff; z-index: 20; }
        #clear-full-image { width: 100%; height: 100%; object-fit: contain; }
        .hit-area { position: absolute; cursor: pointer; z-index: 100; }
        #ui-control-panel { width: 90%; max-width: 480px; text-align: center; padding-top: 5px; position: relative; z-index: 9999; }
        .action-btn { display: block; width: 100%; padding: 16px; margin: 10px 0; color: white; border: none; border-radius: 15px; font-size: 18px; font-weight: bold; cursor: pointer; -webkit-tap-highlight-color: transparent; }
        .btn-main { background: #ad1457; box-shadow: 0 4px 0 #78002e; }
        .btn-light { background: #f06292; box-shadow: 0 4px 0 #ad1457; }
        .btn-deep { background: #e91e63; box-shadow: 0 4px 0 #c2185b; }
        .btn-sub { background: #888; box-shadow: 0 4px 0 #555; }
        .btn-puzzle { background: #28a745; box-shadow: 0 4px 0 #1e7e34; }
    </style>
</head>
<body>

<div id="game-header"><div id="timer-box">TIME: 00:00</div></div>
<div id="puzzle-info-area">
    <img src="image-3.jpg" id="puzzle-sample-img">
    <div id="puzzle-stats">手数: 0</div>
</div>

<div id="portrait-frame" class="content-frame">
    <div id="screen-top" style="width:100%; height:100%; position:relative;">
        <img src="Top.png" class="full-asset">
        <div class="hit-area" style="top:60%; left:15%; width:70%; height:25%;" onclick="toSelect()"></div>
    </div>
    <div id="screen-select" style="width:100%; height:100%; position:relative; display:none;">
        <img src="Select.png" class="full-asset">
        <div class="hit-area" style="top:11%; left:11%; width:78%; height:15%;" onclick="toPuzzle()"></div>
        <div class="hit-area" style="top:31%; left:11%; width:78%; height:15%;" onclick="toBreakout()"></div>
    </div>
</div>

<div id="landscape-frame" class="content-frame"><canvas id="gameCanvas" width="480" height="320"></canvas></div>
<div id="puzzle-frame" class="content-frame">
    <div id="puzzle-board"></div>
    <div id="clear-layer"><img src="image-3.jpg" id="clear-full-image"></div>
</div>

<div id="ui-control-panel">
    <div id="puzzle-controls" style="display:none;">
        <button id="puzzle-start-btn" class="action-btn btn-puzzle" onclick="shufflePuzzle()">シャッフルして開始！</button>
        <button class="action-btn btn-deep" onclick="backToSelect()">Game selection</button>
    </div>
    <div id="controls-miss" style="display:none;">
        <button class="action-btn btn-main" onclick="retryBreakout()">あきらめない！</button>
        <button class="action-btn btn-light" onclick="toBreakout()">最初からやり直す</button>
        <button class="action-btn btn-deep" onclick="backToSelect()">Game selection</button>
    </div>
    <div id="controls-win" style="display:none;">
        <div id="win-message" style="font-size: 16px; color: #ad1457; font-weight: bold; margin-bottom: 10px;"></div>
        <button id="win-retry-btn" class="action-btn btn-main">もう一度遊ぶ</button>
        <button class="action-btn btn-deep" onclick="backToSelect()">Game selection</button>
        <button class="action-btn btn-sub" onclick="location.reload()">タイトルに戻る</button>
    </div>
</div>

<script>
    const canvas = document.getElementById("gameCanvas"), ctx = canvas.getContext("2d");
    const header = document.getElementById("game-header"), timerBox = document.getElementById("timer-box");
    const pFrame = document.getElementById("portrait-frame"), lFrame = document.getElementById("landscape-frame"), pzFrame = document.getElementById("puzzle-frame"), pzInfo = document.getElementById("puzzle-info-area");
    const sTop = document.getElementById("screen-top"), sSelect = document.getElementById("screen-select");
    const cMiss = document.getElementById("controls-miss"), cWin = document.getElementById("controls-win"), winRetryBtn = document.getElementById("win-retry-btn");
    const pzControls = document.getElementById("puzzle-controls"), pzStats = document.getElementById("puzzle-stats"), winMsg = document.getElementById("win-message");
    const pzClearLayer = document.getElementById("clear-layer"), pzBoard = document.getElementById("puzzle-board");

    let gameState = "TOP", startTime, timerId, totalPaused = 0, pauseStart, animId;
    const ballRadius = 10, paddleWidth = 80;
    let x, y, dx, dy, paddleX, score, speedMultiplier = 1.0;
    const imgWin = new Image(), imgMiss = new Image();
    imgWin.src = 'Image.png'; imgMiss.src = 'Miss.png';
    let bricks = [], tiles = [1, 2, 3, 4, 5, 6, 7, 8, null], moveCount = 0;

    function stopProcesses() {
        if(animId) cancelAnimationFrame(animId);
        if(timerId) clearInterval(timerId);
        animId = null; timerId = null; isDragging = false; lastX = null;
    }

    function hideAll() {
        stopProcesses();
        pFrame.style.display = lFrame.style.display = pzFrame.style.display = pzInfo.style.display = cMiss.style.display = cWin.style.display = pzControls.style.display = header.style.display = "none";
        pzClearLayer.style.display = "none"; pzBoard.style.display = "grid";
    }

    function toSelect() { sTop.style.display = "none"; sSelect.style.display = "block"; gameState = "SELECT"; }
    function backToSelect() { hideAll(); pFrame.style.display = "block"; sSelect.style.display = "block"; gameState = "SELECT"; }

    function toBreakout() {
        hideAll(); lFrame.style.display = "block"; header.style.display = "flex";
        initBreakout(); startTimer(true);
        gameState = "PLAY_BRK"; winRetryBtn.onclick = toBreakout; drawBreakout();
    }
    function initBreakout() {
        x = canvas.width/2; y = canvas.height-30; dx = 2.5; dy = -2.5; speedMultiplier = 1.0;
        paddleX = (canvas.width - paddleWidth) / 2; score = 0; totalPaused = 0;
        bricks = [];
        for(let c=0; c<5; c++) { bricks[c] = []; for(let r=0; r<3; r++) { bricks[c][r] = { x: 0, y: 0, status: 1 }; } }
    }

    /* 指示通り、ここだけ徹底修正：再開ロジック */
    function retryBreakout() {
        if(animId) cancelAnimationFrame(animId); // 重複防止
        cMiss.style.display = "none";
        if (pauseStart) totalPaused += (Date.now() - pauseStart);
        pauseStart = null;
        gameState = "PLAY_BRK";
        startTimer(false);
        drawBreakout(); // ループ再開
    }

    function drawBreakout() {
        if (gameState !== "PLAY_BRK") return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (speedMultiplier < 2.0) speedMultiplier += 0.00015;
        for(let c=0; c<5; c++) {
            for(let r=0; r<3; r++) {
                let b = bricks[c][r];
                if(b.status === 1) {
                    let bx = (c * 85) + 30, by = (r * 30) + 30; b.x = bx; b.y = by;
                    ctx.fillStyle = "#f06292"; ctx.fillRect(bx, by, 75, 20);
                    if(x > bx && x < bx + 75 && y > by && y < by + 20) { dy = -dy; b.status = 0; score++; if(score === 15) { gameState = "WIN_BRK"; stopProcesses(); cWin.style.display = "block"; winMsg.innerText = ""; } }
                }
            }
        }
        ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI*2); ctx.fillStyle = "#ff4081"; ctx.fill(); ctx.closePath();
        ctx.fillStyle = "#ad1457"; ctx.fillRect(paddleX, canvas.height - 10, paddleWidth, 10);
        if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
        if(y + dy < ballRadius) dy = -dy;
        else if(y + dy > canvas.height - ballRadius) {
            if(x > paddleX && x < paddleX + paddleWidth) dy = -Math.abs(dy);
            else { 
                gameState = "MISS_BRK"; 
                if(timerId) clearInterval(timerId); timerId = null;
                pauseStart = Date.now(); 
                cMiss.style.display = "block"; 
                return; 
            }
        }
        x += dx * speedMultiplier; y += dy * speedMultiplier;
        animId = requestAnimationFrame(drawBreakout);
        if (gameState === "MISS_BRK") ctx.drawImage(imgMiss, 0, 0, 480, 320);
        else if (gameState === "WIN_BRK") ctx.drawImage(imgWin, 0, 0, 480, 320);
    }

    /* 9パズル：演出・UI固定 */
    function toPuzzle() {
        hideAll(); pzFrame.style.display = "block"; pzInfo.style.display = "flex"; header.style.display = "flex"; pzControls.style.display = "block";
        document.getElementById("puzzle-start-btn").style.display = "block";
        tiles = [1, 2, 3, 4, 5, 6, 7, 8, null]; moveCount = 0; pzStats.innerText = "手数: 0";
        gameState = "PUZZLE_READY"; winRetryBtn.onclick = toPuzzle; drawPuzzle(); updateTimer(0);
    }
    function shufflePuzzle() {
        document.getElementById("puzzle-start-btn").style.display = "none"; moveCount = 0;
        for (let i = 0; i < 150; i++) {
            const e = tiles.indexOf(null), m = [];
            if (e % 3 !== 0) m.push(e - 1); if (e % 3 !== 2) m.push(e + 1); if (e >= 3) m.push(e - 3); if (e < 6) m.push(e + 3);
            const t = m[Math.floor(Math.random() * m.length)]; [tiles[e], tiles[t]] = [tiles[t], tiles[e]];
        }
        startTimer(true); gameState = "PLAY_PZL"; drawPuzzle();
    }
    function drawPuzzle() {
        pzBoard.innerHTML = "";
        tiles.forEach((n, i) => {
            const d = document.createElement("div"); d.className = n === null ? "tile empty" : "tile";
            if (n !== null) {
                const xP = (n - 1) % 3, yP = Math.floor((n - 1) / 3); d.style.backgroundPosition = (xP * 50) + "% " + (yP * 50) + "%";
                d.onclick = () => {
                    if (gameState !== "PLAY_PZL") return; const e = tiles.indexOf(null);
                    if (Math.abs(Math.floor(i/3)-Math.floor(e/3)) + Math.abs((i%3)-(e%3)) === 1) {
                        [tiles[i], tiles[e]] = [tiles[e], tiles[i]]; moveCount++; pzStats.innerText = "手数: " + moveCount; drawPuzzle();
                        if (tiles.every((v, idx) => v === (idx === 8 ? null : idx + 1))) {
                            const finalS = Math.floor((Date.now() - startTime) / 1000);
                            stopProcesses(); gameState = "WIN_PZL";
                            header.style.display = "none"; pzInfo.style.display = "none"; pzBoard.style.display = "none";
                            pzClearLayer.style.display = "block";
                            winMsg.innerText = "クリア！手数: " + moveCount + "回 / タイム: " + finalS + "秒";
                            cWin.style.display = "block"; pzControls.style.display = "none";
                        }
                    }
                };
            }
            pzBoard.appendChild(d);
        });
    }

    function startTimer(isNew) {
        if(timerId) clearInterval(timerId);
        if(isNew) { startTime = Date.now(); totalPaused = 0; }
        timerId = setInterval(() => {
            let elapsed = Math.floor((Date.now() - startTime - totalPaused) / 1000);
            updateTimer(elapsed);
        }, 1000);
    }
    function updateTimer(s) { timerBox.innerText = `TIME: ${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }

    let lastX = null, isDragging = false;
    function handleMove(clientX) {
        if(gameState !== "PLAY_BRK") return;
        const rect = canvas.getBoundingClientRect();
        const scale = canvas.width / rect.width;
        if (lastX !== null) {
            let mv = (clientX - lastX) * scale;
            paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, paddleX + mv));
        }
        lastX = clientX;
    }
    window.addEventListener("mousedown", (e) => { 
        if (e.target.tagName === 'BUTTON') return; 
        if(gameState==="PLAY_BRK") { isDragging = true; lastX = e.clientX; } 
    });
    window.addEventListener("mousemove", (e) => { if(isDragging && gameState==="PLAY_BRK") handleMove(e.clientX); });
    window.addEventListener("mouseup", () => { isDragging = false; lastX = null; });
    window.addEventListener("touchstart", (e) => { 
        if (e.target.tagName === 'BUTTON') return; 
        if(gameState==="PLAY_BRK") { lastX = e.touches[0].clientX; } 
    }, {passive: false});
    window.addEventListener("touchmove", (e) => { 
        if(gameState==="PLAY_BRK") { e.preventDefault(); handleMove(e.touches[0].clientX); } 
    }, {passive: false});
    window.addEventListener("touchend", () => { lastX = null; });
</script>
</body>
</html>
