<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Breakout Game - Fixed Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #fce4ec;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            background: #ffffff;
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            touch-action: none;
        }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    let ballRadius = 10;
    let x, y, dx, dy, paddleX, score, gameState;
    const paddleHeight = 10;
    const paddleWidth = 75;
    const brickRowCount = 3;
    const brickColumnCount = 5;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    let rightPressed = false;
    let leftPressed = false;
    let bricks = [];

    const winImage = new Image();
    winImage.src = 'Image.png';
    const gameOverImage = new Image();
    gameOverImage.src = 'Miss.png';

    function initGame() {
        x = canvas.width / 2;
        y = canvas.height - 30;
        dx = 2;
        dy = -2;
        paddleX = (canvas.width - paddleWidth) / 2;
        score = 0;
        gameState = "playing";
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
    }

    // キーボード・マウス・タッチのイベント
    document.addEventListener("keydown", (e) => {
        if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
        else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
    }, false);
    document.addEventListener("keyup", (e) => {
        if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
        else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    }, false);
    document.addEventListener("mousemove", (e) => {
        const relativeX = e.clientX - canvas.offsetLeft;
        if (relativeX > 0 && relativeX < canvas.width) paddleX = relativeX - paddleWidth / 2;
    }, false);

    // スマホ操作とリスタート用クリック
    canvas.addEventListener("touchstart", (e) => {
        if (gameState !== "playing") {
            initGame();
            draw();
        } else {
            handleTouch(e);
        }
    }, {passive: false});
    canvas.addEventListener("touchmove", handleTouch, {passive: false});
    canvas.addEventListener("click", () => {
        if (gameState !== "playing") {
            initGame();
            draw();
        }
    });

    function handleTouch(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const touchX = (touch.clientX - rect.left) * scaleX;
        paddleX = touchX - paddleWidth / 2;
    }

    function collisionDetection() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                        dy = -dy;
                        b.status = 0;
                        score++;
                        if (score === brickRowCount * brickColumnCount) gameState = "win";
                    }
                }
            }
        }
    }

    function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#ff4081";
        ctx.fill();
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = "#ad1457";
        ctx.fill();
        ctx.closePath();
    }

    function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                if (bricks[c][r].status === 1) {
                    const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                    const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    ctx.fillStyle = "#f06292";
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === "playing") {
            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
            if (y + dy < ballRadius) dy = -dy;
            else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    gameState = "over";
                }
            }

            if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 7;
            else if (leftPressed && paddleX > 0) paddleX -= 7;

            x += dx;
            y += dy;
            requestAnimationFrame(draw);

        } else if (gameState === "win") {
            // 画像の比率を維持して描画
            const ratio = Math.min(canvas.width / winImage.width, canvas.height / winImage.height);
            const nw = winImage.width * ratio;
            const nh = winImage.height * ratio;
            ctx.drawImage(winImage, (canvas.width - nw) / 2, (canvas.height - nh) / 2, nw, nh);
        } else if (gameState === "over") {
            const ratio = Math.min(canvas.width / gameOverImage.width, canvas.height / gameOverImage.height);
            const nw = gameOverImage.width * ratio;
            const nh = gameOverImage.height * ratio;
            ctx.drawImage(gameOverImage, (canvas.width - nw) / 2, (canvas.height - nh) / 2, nw, nh);
        }
    }

    initGame();
    draw();
</script>

</body>
</html>
