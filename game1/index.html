<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Breakout Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #fce4ec;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            background: #ffffff;
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            max-width: 95vw;
            max-height: 70vh;
            width: auto;
            height: auto;
            touch-action: none;
        }
        .instruction {
            margin-top: 20px;
            color: #ad1457;
            font-weight: bold;
        }
    </style>
</head>
<body onclick="handleGlobalClick()" ontouchstart="handleGlobalClick()">

<canvas id="myCanvas" width="480" height="320"></canvas>
<div id="msg" class="instruction">パドルを動かしてボールを打ち返そう！</div>

<script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");
    const msgDiv = document.getElementById("msg");

    let ballRadius = 10;
    let x, y, dx, dy, paddleX, score, gameState;
    const paddleHeight = 10;
    const paddleWidth = 75;
    const brickRowCount = 3;
    const brickColumnCount = 5;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    let bricks = [];
    const winImage = new Image();
    winImage.src = 'Image.png';
    const gameOverImage = new Image();
    gameOverImage.src = 'Miss.png';

    function initGame() {
        x = canvas.width / 2;
        y = canvas.height - 30;
        dx = 2;
        dy = -2;
        paddleX = (canvas.width - paddleWidth) / 2;
        score = 0;
        gameState = "playing";
        msgDiv.innerText = "パドルを動かしてボールを打ち返そう！";
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
    }

    // 画面全体のどこかを触った時の処理
    function handleGlobalClick() {
        if (gameState !== "playing") {
            initGame();
            draw();
        }
    }

    // パドル操作（マウス）
    document.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const relativeX = (e.clientX - rect.left) * (canvas.width / rect.width);
        if (relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth / 2;
        }
    }, false);

    // パドル操作（タッチ）
    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        paddleX = touchX - paddleWidth / 2;
    }, {passive: false});

    function collisionDetection() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                        dy = -dy;
                        b.status = 0;
                        score++;
                        if (score === brickRowCount * brickColumnCount) {
                            gameState = "win";
                            msgDiv.innerText = "CLEAR! 画面をタップしてリスタート";
                        }
                    }
                }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === "playing") {
            // ブロック描画
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.fillStyle = "#f06292";
                        ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
                    }
                }
            }
            // ボール描画
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#ff4081";
            ctx.fill();
            ctx.closePath();
            // パドル描画
            ctx.fillStyle = "#ad1457";
            ctx.fillRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);

            collisionDetection();

            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
            if (y + dy < ballRadius) dy = -dy;
            else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    gameState = "over";
                    msgDiv.innerText = "GAME OVER... 画面をタップしてリスタート";
                }
            }
            x += dx;
            y += dy;
            requestAnimationFrame(draw);

        } else if (gameState === "win") {
            ctx.drawImage(winImage, 0, 0, canvas.width, canvas.height);
        } else if (gameState === "over") {
            ctx.drawImage(gameOverImage, 0, 0, canvas.width, canvas.height);
        }
    }

    initGame();
    draw();
</script>
</body>
</html>
