<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ブロック崩し - スマホ対応版</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #2c3e50; 
            font-family: 'Helvetica Neue', Arial, sans-serif;
            /* スマホでの不要な動作を防止 */
            touch-action: none; 
            user-select: none;
        }
        canvas { 
            background: #ffffff; 
            border: 4px solid #34495e; 
            border-radius: 8px;
            display: block; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 95vw; /* スマホ画面からはみ出さないよう調整 */
            height: auto;
        }
        #info-panel {
            width: 480px;
            max-width: 95vw;
            display: flex;
            justify-content: space-between;
            color: white;
            margin-bottom: 5px;
            font-size: 1.2em;
            font-weight: bold;
        }
        #message { 
            margin-top: 15px; 
            color: #ecf0f1; 
        }
        .overlay {
            position: absolute;
            display: none; 
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
            z-index: 10;
            text-align: center;
            width: 80%;
            max-width: 350px;
        }
        #miss-screen img { max-width: 180px; margin-bottom: 15px; }
        #clear-screen img { 
            max-width: 100%; 
            border-radius: 10px; 
            margin-bottom: 15px; 
            border: 5px solid #f1c40f; 
        }
        .btn-group { display: flex; gap: 10px; margin-top: 15px; }
        button {
            padding: 12px 24px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-reset { background-color: #e74c3c; }
    </style>
</head>
<body>

    <div id="info-panel">
        <div>TIME: <span id="timer">0.0</span>s</div>
    </div>

    <canvas id="gameCanvas" width="480" height="320"></canvas>
    <div id="message">画面をタップしてスタート！</div>

    <div id="miss-screen" class="overlay">
        <img src="Miss.png" alt="Miss image">
        <div class="btn-group">
            <button onclick="continueGame()">CONTINUE</button>
            <button class="btn-reset" onclick="resetFullGame()">RESTART</button>
        </div>
    </div>

    <div id="clear-screen" class="overlay">
        <h2 style="color:#e67e22; font-size: 2.5em;">★ CLEAR ★</h2>
        <p id="final-time" style="font-size: 1.2em; font-weight: bold;"></p>
        <img src="Image.png" alt="Clear Bonus Image">
        <button onclick="document.location.reload()">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timerElement = document.getElementById('timer');
        const clearScreen = document.getElementById('clear-screen');
        const missScreen = document.getElementById('miss-screen');
        const message = document.getElementById('message');

        let ballRadius = 10;
        let x, y, dx, dy;
        let paddleHeight = 12;
        let paddleWidth = 85;
        let paddleX = (canvas.width - paddleWidth) / 2;

        let brickRowCount = 3;
        let brickColumnCount = 5;
        let brickWidth = 75;
        let brickHeight = 20;
        let brickPadding = 10;
        let brickOffsetTop = 30;
        let brickOffsetLeft = 35;

        let bricks = [];
        let score = 0;
        let isBallMoving = false; 
        let gameActive = true;   
        let startTime = 0, totalPausedTime = 0, pauseStartTime = 0, timerInterval;

        function initBricks() {
            bricks = [];
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }
        }

        function resetBallPosition() {
            x = paddleX + paddleWidth / 2;
            y = canvas.height - paddleHeight - ballRadius - 2;
            dx = 3; dy = -3;
            isBallMoving = false;
            message.style.visibility = "visible";
        }

        // マウスとタッチの両方に対応した操作関数
        function moveHandler(e) {
            let relativeX;
            if (e.touches) {
                // タッチ操作の場合
                relativeX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
            } else {
                // マウス操作の場合
                relativeX = e.clientX - canvas.getBoundingClientRect().left;
            }
            
            // キャンバスの表示サイズに合わせて座標を調整
            let scaleX = canvas.width / canvas.getBoundingClientRect().width;
            let canvasX = relativeX * scaleX;

            if (canvasX > 0 && canvasX < canvas.width) {
                paddleX = canvasX - paddleWidth / 2;
                if (!isBallMoving) x = paddleX + paddleWidth / 2; 
            }
        }

        document.addEventListener('mousemove', moveHandler, false);
        document.addEventListener('touchmove', (e) => {
            moveHandler(e);
            e.preventDefault(); // スクロール防止
        }, { passive: false });

        canvas.addEventListener('mousedown', startAction);
        canvas.addEventListener('touchstart', (e) => {
            startAction();
            e.preventDefault();
        }, { passive: false });

        function startAction() {
            if (!isBallMoving && gameActive && missScreen.style.display !== "flex") {
                isBallMoving = true;
                message.style.visibility = "hidden";
                startTimer();
            }
        }

        function startTimer() {
            if (!startTime) {
                startTime = Date.now();
                timerInterval = setInterval(() => {
                    if (isBallMoving) {
                        let elapsedTime = (Date.now() - startTime - totalPausedTime) / 1000;
                        timerElement.textContent = elapsedTime.toFixed(1);
                    }
                }, 100);
            } else if (pauseStartTime) {
                totalPausedTime += (Date.now() - pauseStartTime);
                pauseStartTime = 0;
            }
        }

        function stopTimer() { pauseStartTime = Date.now(); }

        function handleMiss() {
            isBallMoving = false;
            stopTimer(); 
            missScreen.style.display = "flex";
        }

        function continueGame() {
            missScreen.style.display = "none";
            resetBallPosition();
        }

        function resetFullGame() { location.reload(); }

        function collisionDetection() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    let b = bricks[c][r];
                    if(b.status == 1) {
                        if(x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            score++;
                            if(score == brickRowCount * brickColumnCount) {
                                gameActive = false;
                                clearInterval(timerInterval);
                                document.getElementById('final-time').textContent = "CLEAR TIME: " + timerElement.textContent + "s";
                                clearScreen.style.display = "flex";
                            }
                        }
                    }
                }
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#e74c3c";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#3498db";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    if(bricks[c][r].status == 1) {
                        let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#f1c40f";
                        ctx.fill();
                        ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
                        ctx.closePath();
                    }
                }
            }
        }

        function draw() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            if (isBallMoving) {
                if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
                if (y + dy < ballRadius) dy = -dy;
                else if (y + dy > canvas.height - ballRadius) {
                    if (x > paddleX && x < paddleX + paddleWidth) {
                        dy = -dy;
                    } else {
                        handleMiss(); 
                    }
                }
                x += dx;
                y += dy;
            }
            requestAnimationFrame(draw);
        }

        initBricks();
        resetBallPosition();
        draw();
    </script>
</body>
</html>
